!######################################################################
! This routine is part of
! ESpinS - Esfahan Spin Simulation 
! (c) 2016-2019 Dr. Nafise Rezaei and Dr. Mojtaba Alaei
! Physics Department, Isfahan University of Technology, Isfahan, Iran
!
! This program is free software: you can redistribute it and/or modify it 
! under the terms of the GNU General Public License as published by the 
! Free Software Foundation, either version 3 of the License, or 
! (at your option) any later version.
!
! This program is distributed in the hope that it will be useful, but 
! WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
! or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
! for more details.
!
! You should have received a copy of the GNU General Public License along 
! with this program. If not, see http://www.gnu.org/licenses. 
!######################################################################

program mc     

  use mc_constants, only : dp
  use mc_parameters
  use mc_io
  use mc_neighbors
  use mc_ham
  use mc_jij      
  use mc_bij      
  use mc_dij      
  use mc_mcarlo       
  use mc_pt           
  use mc_comms, only : on_root,num_nodes, comms_setup, comms_end,&
                       comms_bcast,comms_barrier,comms_init_random
  use mc_common

  implicit none

  integer          :: i,len_seedname
  !integer          :: ierr
  real(kind=dp)    :: r1,time0,time1,time2
  character(len=9) :: stat,pos
  logical          :: mcerr_found
  ! Put some descriptive comments here
  !
  call comms_setup

  if(on_root) then
     time0=io_time()
     call io_get_seedname
     len_seedname = len(seedname)
  end if

  !call comms_bcast(len_seedname,1)
  !call comms_bcast(seedname,len_seedname)

  if (on_root) then
     ! If an error file (generated by pt) exists, I delete it
     ! Note: I do it only for the error file generated from the root node; 
     ! If error files generated by other nodes exist, I don't do anything for them
     inquire(file=trim(seedname)//'.node_00000.mcerr',exist=mcerr_found)
     if (mcerr_found) then
        stdout=io_file_unit()
        open(unit=stdout,file=trim(seedname)//'.node_00000.mcerr',status='old',position='append')
        close(stdout,status='delete')
     end if

     stat='replace'
     pos='rewind'
     stdout=io_file_unit()
     open(unit=stdout,file=trim(seedname)//'.mcout',status=trim(stat),position=trim(pos))

     call param_write_header
     if(num_nodes==1) then
#ifdef MPI        
        write(stdout,'(/,1x,a)') 'Running in serial (with parallel executable)'
#else
        write(stdout,'(/,1x,a)') 'Running in serial (with serial executable)'
#endif
     else
        write(stdout,'(/,1x,a,i3,a/)')&
             'Running in parallel on ',num_nodes,' CPUs'
     endif
  end if

  ! Read onto the root node all the input parameters from seendame.mcin, 
  !
  if(on_root) then
    call param_read
    call param_write
    time1=io_time()
    write(stdout,'(1x,a25,f11.3,a)')&
         'Time to read parameters  ',time1-time0,' (sec)'

    if(inputfile_setup1) then
      call neighbors_get()
      call neighbors_write()
      call neighbors_check()
      call inp2mcin_write()
      call neighbors_dealloc()
      call param_first_dealloc()
      call param_second_dealloc()
      write(stdout,'(1x,a25,f11.3,a)') 'Time to write neighbors   ',io_time(),' (sec)'
      write(stdout,'(/a)') ' Exiting... '//trim(seedname)//'.neigh written.'
      write(stdout,'(/a)') ' Exiting... '//trim(seedname)//'.inp2.mcin written.'
      call io_print_timings()
      stop
    endif
    if(inputfile_setup2) then
      call neighbors_get()
      call neighbors_write()
      call neighbors_check()
      call mcin_write()
      call neighbors_dealloc()
      call param_first_dealloc()
      call param_second_dealloc()
      write(stdout,'(1x,a25,f11.3,a)') 'Time to write neighbors   ',io_time(),' (sec)'
      write(stdout,'(/a)') ' Exiting... '//trim(seedname)//'.neigh written.'
      write(stdout,'(/a)') ' Exiting... '//trim(seedname)//'.mcin written.'
      call io_print_timings()
      stop
    endif
    if(hamfile_setup) then
      call ham_get()
      call ham_write()
      call ham_dealloc()
      call neighbors_dealloc()
      call param_first_dealloc()
      call param_second_dealloc()
      write(stdout,'(1x,a25,f11.3,a)') 'Time to write Hamiltonian ',io_time(),' (sec)'
      write(stdout,'(/a)') ' Exiting... '//trim(seedname)//'.neigh written.'
      write(stdout,'(/a)') ' Exiting... '//trim(seedname)//'.ham   written.'
      call io_print_timings()
      stop
    endif

    call param_memory_estimate
    ! I now calculate jij,bij,dij matrix only on on_root node.
    call jij_setup()
    call jij_get()
    time2=io_time()
    write(stdout,'(1x,a25,f11.3,a)') 'Time to get Jij matrix   ',time2-time1,' (sec)'

    if (have_biquad) then
       call bij_setup()
       call bij_get()
       time1=io_time()
       write(stdout,'(1x,a25,f11.3,a)') 'Time to get Bij matrix   ',time1-time2,' (sec)'
    endif

    if (have_dm) then
       call dij_setup()
       call dij_get()
       time2=io_time()
       write(stdout,'(1x,a25,f11.3,a)') 'Time to get Dij matrix   ',time2-time1,' (sec)'
    endif

    call param_first_dealloc()
  end if

  ! We now distribute a subset of the parameters to the other nodes
  call mcint_param_dist
  call mcint_data_dist

  !Initialise random number
  call comms_init_random(lseed,seeds,state)
  if(on_root) call param_write_seed()

  ! STart MONTE CARLO or Parallel tempering
  if(.not. pt) then
    call mcarlo_main

    if(on_root) then
       time2=io_time()
       write(stdout,'(/1x,a,f11.3,a)')&
            'Time for montecarlo ',time2-time1,' (sec)'
    endif
  else
    call pt_main

    if(on_root) then
      time2=io_time()
      write(stdout,'(/1x,a,f11.3,a)')&
           'Time for Parallel-Tempering montecarlo ',time2-time1,' (sec)'
    endif
  endif


  ! I put a barrier here before calling the final time printing routines,
  ! just to be sure that all processes have arrived here.
  call comms_barrier

  call param_second_dealloc()

  call jij_dealloc()
  if(have_biquad) call bij_dealloc()
  if(have_dm)     call dij_dealloc()
  
  if(on_root) then
    write(stdout,'(/,1x,a25,f11.3,a)')&
         'Total Execution Time     ',io_time(),' (sec)'
    call io_print_timings()

    if(.not.pt ) then
       write(stdout,'(/,1x,a)') 'All done: mcarlo exiting'
    else
       write(stdout,'(/,1x,a)') 'All done: ptmc exiting'
    endif

    close(stdout)
  end if

  call comms_end

end program mc

